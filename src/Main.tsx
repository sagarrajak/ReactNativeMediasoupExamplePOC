import { Device } from 'mediasoup-client';
import { DtlsParameters, IceCandidate, IceParameters, Transport } from 'mediasoup-client/types';
import { useEffect, useState } from 'react';
import {
  SafeAreaView,
  ScrollView,
  StyleSheet,
  Text,
  TouchableOpacity,
  View,
} from 'react-native';
import { mediaDevices, MediaStream, RTCView } from 'react-native-webrtc';
import { io, Socket } from 'socket.io-client';

export default function Main() {
  // State for Media Streams
  const [localStream, setLocalStream] = useState<MediaStream | null>(null);
  const [remoteStream, setRemoteStream] = useState<MediaStream | null>(null);

  // Mediasoup & Socket States
  const [socket, setSocket] = useState<Socket | null>(null);
  const [device, setDevice] = useState<Device | null>(null);
  const [rtpCapabilities, setRtpCapabilities] = useState<any>(null);
  const [producerTransport, setProducerTransport] = useState<Transport | null>(
    null,
  );
  const [consumerTransport, setConsumerTransport] = useState<any>(null);

  const [params, setParams] = useState({
    encodings: [
      { rid: 'r0', maxBitrate: 100000, scalabilityMode: 'S1T3' },
      { rid: 'r1', maxBitrate: 300000, scalabilityMode: 'S1T3' },
      { rid: 'r2', maxBitrate: 900000, scalabilityMode: 'S1T3' },
    ],
    codecOptions: { videoGoogleStartBitrate: 1000 },
  });

  useEffect(() => {
    // Replace with your server IP (Don't use localhost for physical devices)
    const newSocket = io('http://192.168.1.136:4000/mediasoup');

    setSocket(newSocket);

    newSocket.on('connection-success', () => {
      startCamera();
    });

    return () => {
      newSocket.disconnect();
    };
  }, []);

  const startCamera = async () => {
    try {
      const stream = await mediaDevices.getUserMedia({
        video: true,
        audio: true,
      });
      setLocalStream(stream);

      const track = stream.getVideoTracks()[0];
      setParams((current: any) => ({ ...current, track }));
    } catch (error) {
      console.error('Error accessing camera:', error);
    }
  };

  const getRouterRtpCapabilities = async () => {
    socket?.emit('getRouterRtpCapabilities', (data: any) => {
      if (data.error) {
        console.error('Router capabilities error:', data.error);
        return;
      }
      setRtpCapabilities(data.routerRtpCapabilities);
      console.log(`Got Router RTP Capabilities ${JSON.stringify(data.routerRtpCapabilities)}`);
    });
  };

  const createDevice = async () => {
    try {
      const newDevice = new Device();
      await newDevice.load({ routerRtpCapabilities: rtpCapabilities });
      setDevice(newDevice);
      console.log('Device Created');
    } catch (error: any) {
      console.error('Device Load Error:', error);
      if (error.name === "UnsupportedError") {
        console.error("Browser not supported");
      }
    }
  };

  /*
   * ICE servers (STUN/TURN) configuration.
   * STUN servers are used to discover the public IP address.
   * TURN servers are used to relay traffic if P2P fails.
   */
  const iceServers = [
    {
      urls: 'stun:stun.l.google.com:19302',
    },
    {
      urls: 'turn:test.xxxx.com:3478',
      username: '',
      credential: '',
    },
  ];


  const createSendTransport = async () => {
    socket?.emit(
      'createTransport',
      { sender: true },
      ({
        params: serverParams,
      }: {
        params: {
          /**
           * A unique identifier generated by mediasoup for the transport.
           * Necessary for differentiating between multiple transports.
           */
          id: string;
          /**
           * Interactive Connectivity Establishment (ICE) parameters.
           * Necessary for the negotiation of network connections.
           */
          iceParameters: IceParameters;
          /**
           * Array of ICE candidates.
           * Necessary for establishing network connectivity through NATs and firewalls.
           */
          iceCandidates: IceCandidate[];
          /**
           * Datagram Transport Layer Security (DTLS) parameters.
           * Necessary for securing the transport with encryption.
           */
          dtlsParameters: DtlsParameters;
          /**
           * Error object if any error occurs during transport creation.
           * */
          error?: unknown;
        };
      }) => {
        if (serverParams.error) return;

        // Add iceServers to the transport options
        const transport = device?.createSendTransport({ ...serverParams, iceServers });
        setProducerTransport(transport || null);

        transport?.on(
          'connect',
          async ({ dtlsParameters }, callback, errback) => {
            try {
              console.log("----------> producer transport has connected");
              socket.emit('connectProducerTransport', { dtlsParameters });
              callback();
            } catch (error) {
              errback(error as any);
              console.error(error);
              console.error("createTransport on connect");
            }
          },
        );

        transport?.on('produce', async (parameters, callback, errback) => {
          console.log("----------> transport-produce");
          try {
            socket.emit('transport-produce', parameters, ({ id }: any) => {
              callback({ id });
            });
          } catch (error) {
            errback(error as any);
            console.error(error);
            console.error("createTransport on producer");
          }
        });
      },
    );
  };

  const connectSendTransport = async () => {
    if (!producerTransport) return;
    const localProducer = await producerTransport.produce(params);

    console.log('Producing Media...');
    // Event handlers for track ending and transport closing events
    localProducer?.on('trackended', () => {
      console.log('trackended');
    });
    localProducer?.on('transportclose', () => {
      console.log('transportclose');
    });
  };

  const createRecvTransport = async () => {
    socket?.emit(
      'createTransport',
      { sender: false },
      ({ params: serverParams }: any) => {
        if (serverParams.error) return;

        // Add iceServers to the transport options
        const transport = device?.createRecvTransport({ ...serverParams, iceServers });
        setConsumerTransport(transport);

        transport?.on(
          'connect',
          async ({ dtlsParameters }, callback, errback) => {
            try {
              socket.emit('connectConsumerTransport', { dtlsParameters });
              console.log("----------> consumer transport has connected");
              callback();
            } catch (error) {
              errback(error as any);
              console.error("createRecvTransport on connect");
              console.error(error);
            }
          },
        );
      },
    );
  };

  const connectRecvTransport = async () => {
    socket?.emit(
      'consumeMedia',
      { rtpCapabilities: device?.rtpCapabilities },
      async ({ params: consumeParams }: any) => {
        if (consumeParams.error) return;

        const consumer = await consumerTransport.consume({
          id: consumeParams.id,
          producerId: consumeParams.producerId,
          kind: consumeParams.kind,
          rtpParameters: consumeParams.rtpParameters,
        });

        const { track } = consumer;
        // In React Native WebRTC, we create a new MediaStream and add the track
        const remoteNetStream = new MediaStream([track]);
        setRemoteStream(remoteNetStream)
        console.log(remoteNetStream.toURL());

        socket.emit('resumePausedConsumer', () => { });
        console.log("----------> consumer transport has resumed");
      },
    );
  };


  return (
    <SafeAreaView style={styles.container}>
      <ScrollView contentContainerStyle={styles.scrollContainer}>
        <Text style={styles.title}>Mediasoup RN</Text>
        <View style={styles.videoContainer}>
          {localStream && (
            <RTCView
              streamURL={localStream.toURL()}
              style={styles.video}
              objectFit="cover"
            />
          )}
          <Text>Local Video</Text>
        </View>

        <View style={styles.videoContainer}>
          {remoteStream && (
            <RTCView
              streamURL={remoteStream.toURL()}
              style={styles.video}
              objectFit="cover"
            />
          )}
          <Text>Remote Video</Text>
        </View>
        <View style={styles.buttonGrid}>
          <Button
            title="1. Get Router RTP Capabilities"
            onPress={getRouterRtpCapabilities}
          />
          <Button title="2. Create Device" onPress={createDevice} />
          <Button
            title="3. Create Send Transport"
            onPress={createSendTransport}
          />
          <Button title="4.Connect send transport and produce"
            onPress={connectSendTransport} />
          <Button
            title="5. Create Recv Transport"
            onPress={createRecvTransport}
          />
          <Button title="6. Connect recv transport and consume"
            onPress={connectRecvTransport} />
        </View>
      </ScrollView>
    </SafeAreaView>
  );
}

const styles = StyleSheet.create({
  container: { flex: 1, backgroundColor: '#fff' },
  scrollContainer: { padding: 20, alignItems: 'center' },
  title: { fontSize: 20, fontWeight: 'bold', marginBottom: 20 },
  videoContainer: {
    width: '100%',
    height: 200,
    backgroundColor: '#000',
    marginBottom: 10,
    justifyContent: 'center',
    alignItems: 'center',
  },
  video: { width: '100%', height: '100%' },
  buttonGrid: { width: '100%', marginTop: 20 },
  button: {
    backgroundColor: '#007AFF',
    padding: 12,
    borderRadius: 8,
    marginBottom: 10,
    alignItems: 'center',
  },
  buttonText: { color: '#fff', fontWeight: '600' },
});

const Button = ({ title, onPress }: { title: string; onPress: () => void }) => (
  <TouchableOpacity style={styles.button} onPress={onPress}>
    <Text style={styles.buttonText}>{title}</Text>
  </TouchableOpacity>
);
